use chrono::{NaiveDate, NaiveTime};
use crate::{Lit, Month, Val, YearMonth};
use raystack::{Number, TagName};
use std::collections::HashMap;
use std::str::FromStr;

grammar;

pub Val: Val = {
    Bool => Val::Lit(Lit::Bool(<>)),
    Date => Val::Lit(Lit::Date(<>)),
    Null => Val::Lit(Lit::Null),
    Num => Val::Lit(Lit::Num(<>)),
    Str => Val::Lit(Lit::Str(<>)),
    Time => Val::Lit(Lit::Time(<>)),
    Uri => Val::Lit(Lit::Uri(<>)),
    YearMonth => Val::Lit(Lit::YearMonth(<>)),
    "[" "]" => Val::List(vec![]),
    "[" <first_val:Val> <vals:("," <Val>)*> "]" => {
        let mut vals = vals;
        vals.insert(0, first_val);
        Val::List(vals)
    },
    "{" "}" => Val::Dict(HashMap::new()),
    "{" <first_entry:DictEntry> <entries:("," <DictEntry>)*> "}" => {
        let mut entries = entries;
        entries.insert(0, first_entry);
        Val::Dict(entries.into_iter().collect())
    }
}

pub YearMonth: YearMonth = {
    r"[1-9][0-9]{3}-[0-9]{2}" => {
        let parts = <>.split("-").collect::<Vec<_>>();
        let year = u32::from_str(parts[0]).unwrap();
        let month = u32::from_str(parts[1]).unwrap();
        let month = Month::from_int(month).unwrap();
        YearMonth::new(year, month)
    }
}

pub Time: NaiveTime = {
    r"[0-9]{2}:[0-9]{2}(:[0-9]{2})?" => {
        let with_secs = NaiveTime::parse_from_str(<>, "%H:%M:%S");
        match &with_secs {
            Ok(_) => with_secs.unwrap(),
            Err(_) => NaiveTime::parse_from_str(<>, "%H:%M").unwrap(),
        }
    }
}

pub Date: NaiveDate = {
    r"[1-9][0-9]{3}-[0-9]{2}-[0-9]{2}" => {
        NaiveDate::parse_from_str(<>, "%Y-%m-%d").unwrap()
    }
}

Null: () = {
    "null" => (),
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

DictEntry: (TagName, Box<Val>) = {
    <tag_name:TagName> ":" <val:Val> => (tag_name, Box::new(val)),
}

pub Str: String = {
    r#""([^\\"]|\\[nt"\\])*""# => {
        let s = <>;
        let len = s.len();
        s[1..len - 1]
            .replace(r#"\""#, r#"""#)
            .replace(r"\n", "\n")
            .replace(r"\t", "\t")
            .replace(r"\\", r#"\"#)
            .to_owned()
    },
}

pub Num: Number = {
    <float:Float> <unit:(Unit)?>=> {
        Number::new(float, unit)
    },
}

pub Uri: String = {
    <r"`[^`]*`"> => {
        let s = <>;
        let len = s.len();
        s[1..len - 1].to_owned()
    },
}

pub Float: f64 = {
    <number:r"-?[0-9]+(\.[0-9]+)?"> => f64::from_str(number).unwrap(),
}

pub TagName: TagName = {
    r"[a-z]([a-zA-Z0-9_])*" => TagName::new(<>.to_owned()).unwrap(),
}

pub Unit: String = {
    "percent" => <>.to_owned(),
    "%" => <>.to_owned(),
    "pixel" => <>.to_owned(),
    "px" => <>.to_owned(),
    "decibel" => <>.to_owned(),
    "db" => <>.to_owned(),
}