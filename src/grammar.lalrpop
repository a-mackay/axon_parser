use crate::{Lit, Val};
use raystack::{Number, TagName};
use std::collections::HashMap;
use std::str::FromStr;

grammar;

pub Val: Val = {
    Bool => Val::Lit(Lit::Bool(<>)),
    Str => Val::Lit(Lit::Str(<>)),
    Uri => Val::Lit(Lit::Uri(<>)),
    Num => Val::Lit(Lit::Num(<>)),
    "[" "]" => Val::List(vec![]),
    "[" <first_val:Val> <vals:("," <Val>)*> "]" => {
        let mut vals = vals;
        vals.insert(0, first_val);
        Val::List(vals)
    },
    "{" "}" => Val::Dict(HashMap::new()),
    "{" <first_entry:DictEntry> <entries:("," <DictEntry>)*> "}" => {
        let mut entries = entries;
        entries.insert(0, first_entry);
        Val::Dict(entries.into_iter().collect())
    }
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

DictEntry: (TagName, Box<Val>) = {
    <tag_name:TagName> ":" <val:Val> => (tag_name, Box::new(val)),
}

pub Str: String = {
    r#""([^\\"]|\\[nt"\\])*""# => {
        let s = <>;
        let len = s.len();
        s[1..len - 1]
            .replace(r#"\""#, r#"""#)
            .replace(r"\n", "\n")
            .replace(r"\t", "\t")
            .replace(r"\\", r#"\"#)
            .to_owned()
    },
}

pub Num: Number = {
    <float:Float> <unit:(Unit)?>=> {
        Number::new(float, unit)
    },
}

pub Uri: String = {
    <r"`[^`]*`"> => {
        let s = <>;
        let len = s.len();
        s[1..len - 1].to_owned()
    },
}

pub Float: f64 = {
    <number:r"-?[0-9]+(\.[0-9]+)?"> => f64::from_str(number).unwrap(),
}

pub TagName: TagName = {
    r"[a-z]([a-zA-Z0-9_])*" => TagName::new(<>.to_owned()).unwrap(),
}

pub Unit: String = {
    "percent" => <>.to_owned(),
    "%" => <>.to_owned(),
    "pixel" => <>.to_owned(),
    "px" => <>.to_owned(),
    "decibel" => <>.to_owned(),
    "db" => <>.to_owned(),
}